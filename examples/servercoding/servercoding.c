#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <errno.h>
#include <unistd.h>
#include <netinet/in.h>
#include <sys/socket.h>
#include <sys/wait.h>
#include <sys/types.h>
#include <sys/stat.h>

#include <kodoc/kodoc.h>

void error(char *msg)
{
    perror(msg);
    exit(EXIT_FAILURE);
}

int main(int argc, char *argv[])
{
	int sockfd, new_fd, portno, numbytes, client_length, ack;
	struct sockaddr_in server_addr;
	struct sockaddr_in client_addr;
	struct stat filestat;

	if (argc < 3) {
		fprintf(stdout, "Usage: %s port_number file_name\n", argv[0]);
		error("ERROR: invalid argument");
	}

	if ((sockfd = socket(AF_INET, SOCK_STREAM, 0)) == -1 )
		error("ERROR: socket");

	portno = atoi(argv[1]);	
	server_addr.sin_family = AF_INET;
	server_addr.sin_port = htons(portno);
	server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

	if (bind(sockfd, (struct sockaddr *) &server_addr, sizeof(struct sockaddr)) == -1 )
		error("ERROR: bind");

	if (listen(sockfd, 10) == -1 )
		error("ERROR: listen");

	if (lstat(argv[2], &filestat) < 0)
		error("ERROR : get file size");

	printf("Opening file: \"%s\"\n", argv[2]);
	printf("The file size is %lu bytes\n\n", filestat.st_size);

	FILE *fp;
	fp = fopen(argv[2], "r");
	client_length = sizeof(client_addr);
	if ((new_fd = accept(sockfd, (struct sockaddr*) &client_addr, 
					(unsigned int *) &client_length)) == -1 )
		error("accept");

	uint32_t max_symbols = 10;
	uint32_t max_symbol_size = 100;

	int32_t codec = kodoc_full_vector;
	int32_t finite_field = kodoc_binary;

	kodoc_factory_t encoder_factory =
	kodoc_new_encoder_factory(codec, finite_field,
                                 max_symbols, max_symbol_size);
	kodoc_coder_t encoder = kodoc_factory_build_coder(encoder_factory);

	uint32_t bytes_used;
	uint32_t payload_size = kodoc_payload_size(encoder);
	uint32_t block_size = kodoc_block_size(encoder);
	uint8_t* payload = (uint8_t*) malloc(payload_size);
	uint8_t* data_in = (uint8_t*) malloc(block_size);

	/* let decoder know how many bytes file size is to end writing file */
	if (write(new_fd, &filestat.st_size, sizeof(filestat.st_size)) < 0)
		error("Error:write file_size failed");

	// Encode one block at a time, check ack to know whether decoder is complete,
	// if block is decoded, read another block and encode data,
	// until all the data is encoded.	
	while (!feof(fp)) {			
		numbytes = fread(data_in, sizeof(char), block_size, fp);

		if (numbytes == 0)
			break;

		printf("\nfread %d bytes\n", numbytes);

		kodoc_set_const_symbols(encoder, data_in, block_size);
		bytes_used = kodoc_write_payload(encoder, payload);

		printf("block_size:%d\n", block_size);
		printf("payload_size:%d\n\n", payload_size);
		printf("Payload generated by encoder, rank = %d,\
				bytes used = %d\n",kodoc_rank(encoder), bytes_used);

		if ((numbytes = write(new_fd, payload, payload_size)) < 0)
			error("Error:write payload failed\n");

		while (1) {

			if (read(new_fd, &ack, sizeof(ack)) < 0)
				error("Error:read ack failed\n");

			if (ack) {
				break;
			} else {
				bytes_used = kodoc_write_payload(encoder, payload);
				printf("Payload generated by encoder, rank = %d, bytes used = %d\n", kodoc_rank(encoder), bytes_used);
				if ((numbytes = write(new_fd, payload, payload_size) < 0))
					error("Error:write payload failed");
			}
		} /* end of while (1) */
	} /* end of while (!feof(fp)) */

	printf("\nserver finished\n");

	free(data_in);
	free(payload);
	kodoc_delete_coder(encoder);
	kodoc_delete_factory(encoder_factory);
	close(new_fd);
	close(sockfd);
	return 0;
}
